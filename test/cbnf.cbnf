// CBNF grammar definition for CBNF

language "CBNF" ;

comment "//" ;
comment "/*" "*/" ;

lexeme identifier "[_a-zA-Z][_\\-a-zA-Z0-9]*" ;

quote string "\"" "\"" "\\" ;

grammar = statement* ;

statement = production ;
statement = "keywords" terminal-list ;
statement = "identifiers" terminal-list ;
statement = "operators" terminal-list ;
statement = "separators" terminal-list ;
statement = "terminators" terminal-list ;
statement = "strings" terminal-list ;
statement = pass-definition ;

terminal-list = "{" terminal* "}" ;

terminal = identifier ;
terminal = string ;

production = "comment" string ";" ;
production = "comment" string string ";" ;
production = "quote" identifier string string string ";" ;
production = "lexeme" identifier string ";" ;
production = identifier "=" rule-expression* ";" ;
production = identifier "=" "..." ";" ;

rule-expression = string ;
rule-expression = identifier ;
rule-expression = identifier "*" ;
rule-expression = identifier "?" ;
rule-expression = identifier "+" ;

string-expression = string ;
string-expression = identifier ;
string-expression = string-expression "+" string-expression ;
string-expression = identifier "." "name" ;
string-expression = "language" "." "name" ;
string-expression = identifier "." "input-name" ;

array-expression = "language" "." "productions" ;
array-expression = identifier "." "productions" ;
array-expression = "language" "." "keywords" ;
array-expression = identifier "." "keywords" ;
array-expression = "language" "." "identifiers" ;
array-expression = identifier "." "identifiers" ;
array-expression = "language" "." "operators" ;
array-expression = identifier "." "operators" ;
array-expression = "language" "." "terminators" ;
array-expression = identifier "." "terminators" ;
array-expression = "language" "." "separators" ;
array-expression = identifier "." "separators" ;
array-expression = "language" "." "strings" ;
array-expression = identifier "." "strings" ;
array-expression = "language" "." "quotes" ;
array-expression = identifier "." "quotes" ;
array-expression = "language" "." "lexemes" ;
array-expression = identifier "." "lexemes" ;
array-expression = "language" "." "line-comments" ;
array-expression = identifier "." "line-comments" ;
array-expression = "language" "." "block-comments" ;
array-expression = identifier "." "block-comments" ;
array-expression = "language" "." "passes" ;
array-expression = identifier "." "passes" ;
array-expression = identifier "." "names" ;
array-expression = identifier ;

boolean-expression = string-expression "==" string-expression ;
boolean-expression = boolean-expression "==" boolean-expression ;
boolean-expression = identifier "." "is-optional" ;
boolean-expression = identifier "." "is-non-empty" ;
boolean-expression = identifier "." "is-list" ;
boolean-expression = "true" ;
boolean-expression = "false" ;
boolean-expression = identifier ;

parse-expression = identifier "." "parse" ;
parse-expression = identifier ;

keywords
{
	"keywords"
	"identifiers"
	"operators"
	"separators"
	"terminators"
	"strings"
	"language"
	"comment"
	"quote"
	"lexeme"
	"pass"
	"requires"
	"output"
	"switch"
	"write"
	"name"
	"for"
	"each"
	"in"
	"productions"
	"names"
	"is-optional"
	"is-non-empty"
	"is-list"
	"true"
	"false"
	"input-name"
	"quotes"
	"lexemes"
	"block-comments"
	"line-comments"
	"passes"
	"parse"
	"walk"
	"as"
}

identifiers
{
	identifier
}

operators
{
	"="
	"{"
	"}"
	"*"
	"+"
	"-"
	"?"
	"."
	"=="
}

separators
{
}

terminators
{
	";"
}

strings
{
	string
}

pass "cpp"
{

{ 
    output language .name + ".cpp" ;
    write "// CP2::Parser definition for " + language .name + "\n\n" ;
    write "#define GE( ... ) GrammarExpression( __VA_ARGS__ )\n\n" ;
    write "const Grammar& Get" + language .name + "Grammar()\n" ;
    write "{\n" ;
    write "\tstatic Grammar kx" + language .name + "Grammar(\n" ;
    write "\t{\n" ;
    for each production in language .productions 
    { 
        write "\t\tGrammarProduction(\"" + production .name + "\",\n" ;
        write "\t\t\t" ;
        join = "" ;
        for each production-name in production .names 
        { 
            write join ;
            if production-name .is-list 
            { 
                if production-name .is-non-empty 
                { 
                    write "+" ;
                    } 
                else 
                { 
                    write "!" ;
                    } 
                } 
            else 
            { 
                if production-name .is-optional 
                { 
                    write "~" ;
                    } 
                } 
            write "GE( \"" + production-name + "\" ) " ;
            join = "+ " ;
            } 
        write "),\n" ;
        } 
    write "\t});\n\n" ;
    write "#undef GE\n\n" ;
    write "\treturn kx" + language .name + "Grammar;\n" ;
    write "\}\n" ;
    } 
}

pass "cbnf"
{

{ 
    output language .name + ".cbnf" ;
    write "// CBNF grammar definition for " + language .name + "\n\n" ;
    write "language \"" + language .name + "\" ;\n\n" ;
    for each value in language .line-comments 
    { 
        write "comment \"" + value + "\" ;\n" ;
        } 
    for each value in language .block-comments 
    { 
        write "comment " ;
        for each part in value 
        { 
            write "\"" + part + "\" " ;
            } 
        write ";\n" ;
        } 
    write "\n" ;
    for each value in language .lexemes 
    { 
        if value .is-optional 
        { 
            } 
        else 
        { 
            write "lexeme " + value .name + " " + value + " ;\n" ;
            } 
        } 
    write "\n" ;
    for each value in language .quotes 
    { 
        write "quote " + value .name + " " ;
        for each part in value 
        { 
            write "\"" + part + "\" " ;
            } 
        write ";\n" ;
        } 
    last = "" ;
    for each production in language .productions 
    { 
        if production .input-name == last 
        { 
            } 
        else 
        { 
            write "\n" ;
            } 
        last = production .input-name ;
        write production .input-name + " = " ;
        join = "" ;
        for each production-name in production .names 
        { 
            write join ;
            write production-name .input-name ;
            if production-name .is-list 
            { 
                if production-name .is-non-empty 
                { 
                    write "+" ;
                    } 
                else 
                { 
                    write "*" ;
                    } 
                } 
            else 
            { 
                if production-name .is-optional 
                { 
                    write "?" ;
                    } 
                } 
            join = " " ;
            } 
        write " ;\n" ;
        } 
    write "\n" ;
    write "keywords\n" ;
    write "{\n" ;
    for each value in language .keywords 
    { 
        write "\t" + value + "\n" ;
        } 
    write "}\n\n" ;
    write "identifiers\n" ;
    write "{\n" ;
    for each value in language .identifiers 
    { 
        write "\t" + value + "\n" ;
        } 
    write "}\n\n" ;
    write "operators\n" ;
    write "{\n" ;
    for each value in language .operators 
    { 
        write "\t" + value + "\n" ;
        } 
    write "}\n\n" ;
    write "separators\n" ;
    write "{\n" ;
    for each value in language .separators 
    { 
        write "\t" + value + "\n" ;
        } 
    write "}\n\n" ;
    write "terminators\n" ;
    write "{\n" ;
    for each value in language .terminators 
    { 
        write "\t" + value + "\n" ;
        } 
    write "}\n\n" ;
    write "strings\n" ;
    write "{\n" ;
    for each value in language .strings 
    { 
        write "\t" + value + "\n" ;
        } 
    write "}\n" ;
    for each compiler-pass in language .passes 
    { 
        write "\npass " + "\"" + compiler-pass .name + "\"" ;
        write "\n" ;
        write "{\n" ;
        tab-prefix = "" ;
        walk compiler-pass .parse as node 
        { 
            if node .is-list 
            { 
                } 
            else 
            { 
                if node == "." 
                { 
                    write "." ;
                    } 
                else 
                { 
                    if node == ";" 
                    { 
                        write node + "\n" + tab-prefix ;
                        } 
                    else 
                    { 
                        if node == "{" 
                        { 
                            write "\n" + tab-prefix ;
                            tab-prefix = tab-prefix + "    " ;
                            } 
                        if node == "}" 
                        { 
                            tab-prefix = tab-prefix - "    " ;
                            } 
                        write node + " " ;
                        if node == "{" 
                        { 
                            write "\n" + tab-prefix ;
                            } 
                        if node == "}" 
                        { 
                            write "\n" + tab-prefix ;
                            } 
                        } 
                    } 
                } 
            } 
        write "}\n" ;
        } 
    } 
}
