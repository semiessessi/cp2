// Copyright (c) 2021 Cranium Software

pass "llvm" switch
{
    output language.name + ".llvm" ;

    write "; LLVM IR code for compiler for " + language.name + "\n\n" ;

    // externs...
    write "declare ccc i32 @puts( i8* nocapture ) nounwind\n" ;
    write "declare ccc i32 @clParseCommandLine( i32, i8** nocapture ) nounwind\n" ;
    write "declare ccc i32 @clHasSwitch( i8* nocapture ) nounwind\n" ;
    write "declare ccc i8* @clMapSwitch( i8* nocapture ) nounwind\n" ;
    write "declare ccc i32 @clFileCount() nounwind\n" ;
    write "declare ccc i32 @clLexerLineComment( i8* nocapture ) nounwind\n" ;
    write "declare ccc i32 @clLexerBlockComment( i8* nocapture, i8* nocapture ) nounwind\n" ;

    write "\n" ;

    // constants...
    title = language.name + " Compiler Generated By CBNF" ;
    write "@.message1 = private constant [" ;
    write title.length-with-null ;
    write " x i8] c\"" + title + "\\00\"\n" ;
    write "@.message2 = private constant [67 x i8] c\"Copyright (c) 2017-2021 Cranium Software Ltd. All rights reserved.\\00\"\n" ;
    write "@.error1001 = private constant [43 x i8] c\"cbnf: error 1001: No source files provided\\00\"\n" ;
    write "@.error1002 = private constant [42 x i8] c\"cbnf: error 1002: No output path provided\\00\"\n" ;
    write "@.outputSwitchShort = private constant [2 x i8] c\"o\\00\"\n" ;

    // lexer constants
    commentCounter = 1 ;
    for each value in language.line-comments
    {
        commentString = value ;
        commentId = commentCounter.to-string;
        write "@.comment" + commentId + " = private constant [" ;
        write commentString.length-with-null ;
        write " x i8] c\"" + commentString + "\\00\"\n" ;
        commentCounter = commentCounter + 1 ;
    }

    commentCounter = 1 ;
    for each value in language.block-comments
    {
        for each part in value
        {
            commentId = commentCounter.to-string;
            write "@.blockComment" + commentId + " = private constant [" ;
            write part.length-with-null ;
            write " x i8] c\"" + part + "\\00\"\n" ;
            commentCounter = commentCounter + 1 ;
        }        
    }

    // check for each pass having it's switch set.
    for each compiler-pass in language.passes
    {
        write "@.pass_" + compiler-pass.name + " = private constant [" ;
        write compiler-pass.name.length-with-null ;
        write " x i8] c\"" + compiler-pass.name + "\\00\"\n" ;
    }

    // functions for passes...

    write "\n" ;
    // the entry point
    write "define ccc i32 @main(i32 %argumentCount, i8** %argumentList) nounwind\n{\n" ;

    // title blurb
    write "\t%" + ssi-counter + " = call i32 @puts(i8* getelementptr inbounds ([" ;
    write title.length-with-null ;
    write " x i8]* @.message1, i32 0, i32 0))\n" ;
    write "\t%" + ssi-counter + " = call i32 @puts(i8* getelementptr inbounds ([67 x i8]* @.message2, i32 0, i32 0))\n" ;

    // parse command line
    write "\t%" + ssi-counter + " = call i32 @clParseCommandLine(i32 %argumentCount, i8** %argumentList)\n" ;

    // check for output file
    outputFile = ssi-counter ;
    write "\t%" + outputFile + " = call i32 @clHasSwitch(i8* getelementptr inbounds ([2 x i8]* @.outputSwitchShort, i32 0, i32 0))\n" ;
    outputFileCheck = ssi-counter ;
    write "\t%" + outputFileCheck + " = icmp ne i32 %" + outputFile + ", 0\n" ;
    write "\tbr i1 %" + outputFileCheck + ", label %hasOutputFile, label %noOutputFile\n" ;

    write "noOutputFile:\n";
    write "\t%" + ssi-counter + " = call i32 @puts(i8* getelementptr inbounds ([42 x i8]* @.error1002, i32 0, i32 0))\n" ;
    write "\tret i32 -1\n" ;

    write "hasOutputFile:\n" ;

    outputFileName = ssi-counter ;
    write "\t%" + outputFileName + " = call i8* @clMapSwitch(i8* getelementptr inbounds ([2 x i8]* @.outputSwitchShort, i32 0, i32 0))\n" ;

    // check for input files
    fileCount = ssi-counter ;
    write "\t%" + fileCount + " = call i32 @clFileCount()\n" ;
    fileCountCheck = ssi-counter;
    write "\t%" + fileCountCheck + " = icmp ne i32 %" + fileCount + ", 0\n" ;
    write "\tbr i1 %" + fileCountCheck + ", label %hasFiles, label %noFiles\n"  ;
    
    write "noFiles:\n";
    write "\t%" + ssi-counter + " = call i32 @puts(i8* getelementptr inbounds ([43 x i8]* @.error1001, i32 0, i32 0))\n" ;
    write "\tret i32 -1\n" ;

    write "hasFiles:\n" ;

    // set up lexer
    

    commentCounter = 1 ;
    for each value in language.line-comments
    {
        commentString = value ;
        commentId = commentCounter.to-string;
        write "\t%" + ssi-counter + " = call i32 @clLexerLineComment(i8* getelementptr inbounds ([" ;
        write commentString.length-with-null ;
        write " x i8]* @.comment" + commentId + ", i32 0, i32 0))\n" ;
        commentCounter = commentCounter + 1 ;
    }

    commentCounter = 1 ;
    for each value in language.block-comments
    {
        write "\t%" + ssi-counter + " = call i32 @clLexerBlockComment(" ;
        joiner = ", " ;
        for each part in value
        {
            commentId = commentCounter.to-string;
            write "i8* getelementptr inbounds ([" ;
            write part.length-with-null ;
            write " x i8]* @.blockComment" + commentId + ", i32 0, i32 0)";
            write joiner ;
            commentCounter = commentCounter + 1 ;
            joiner = "" ;
        }
        write ")\n" ;
    }

    // check for each pass having it's switch set.
    for each compiler-pass in language.passes
    {
        write "\t%" + ssi-counter + " = call i32 @clHasSwitch(i8* getelementptr inbounds ([" ;
        write compiler-pass.name.length-with-null ;
        write " x i8]* @.pass_" + compiler-pass.name + ", i32 0, i32 0))\n" ;
    }

    write "\tret i32 0\n" ;
    write "}\n";

}
