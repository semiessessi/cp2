// Copyright (c) 2021 Cranium Software

pass "llvm" switch
{
    output language.name + ".llvm" ;

    write "; LLVM IR code for compiler for " + language.name + "\n\n" ;

    // externs...
    //write "declare ccc i32 @printf( i8* nocapture, ... ) nounwind\n" ;
    write "declare ccc i32 @puts( i8* nocapture ) nounwind\n" ;
    write "declare ccc i32 @clParseCommandLine( i32, i8** nocapture ) nounwind\n" ;
    write "declare ccc i32 @clHasSwitch( i8* nocapture ) nounwind\n" ;
    write "declare ccc i8* @clMapSwitch( i8* nocapture ) nounwind\n" ;
    write "declare ccc i32 @clFileCount() nounwind\n" ;
    write "declare ccc i8* @clGetFile( i32 ) nounwind\n" ;
    write "declare ccc i32 @clLexerLineComment( i8* nocapture ) nounwind\n" ;
    write "declare ccc i32 @clLexerBlockComment( i8* nocapture, i8* nocapture ) nounwind\n" ;
    write "declare ccc i32 @clLexerQuote( i8* nocapture, i8* nocapture, i8* nocapture, i8* nocapture ) nounwind\n" ;
    write "declare ccc i32 @clLexerRule( i8* nocapture, i8* nocapture ) nounwind\n" ;
    write "declare ccc i32 @clLex( i8* nocapture ) nounwind\n" ;
    write "declare ccc i32 @clParseAppendExpression( i8* nocapture, i8, i8, i8 ) nounwind\n" ;
    write "declare ccc i32 @clParseCreateProduction( i8* nocapture ) nounwind\n" ;
    write "declare ccc i32 @clParseCreateGrammar( i8* nocapture ) nounwind\n" ;
    write "declare ccc i32 @clParseLex( i32 ) nounwind\n" ;

    write "\n" ;

    // constants...
    title = language.name + " Compiler Generated By CBNF" ;
    write "@.message1 = private constant [" ;
    write title.length-with-null ;
    write " x i8] c\"" + title + "\\00\"\n" ;
    write "@.message2 = private constant [67 x i8] c\"Copyright (c) 2017-2021 Cranium Software Ltd. All rights reserved.\\00\"\n" ;
    write "@.message3 = private constant [16 x i8] c\"Lexing files...\\00\"\n" ;
    write "@.message4 = private constant [17 x i8] c\"Parsing files...\\00\"\n" ;
    write "@.error1001 = private constant [43 x i8] c\"cbnf: error 1001: No source files provided\\00\"\n" ;
    write "@.error1002 = private constant [42 x i8] c\"cbnf: error 1002: No output path provided\\00\"\n" ;
    write "@.outputSwitchShort = private constant [2 x i8] c\"o\\00\"\n" ;

    // lexer constants
    commentCounter = 1 ;
    for each value in language.line-comments
    {
        commentId = commentCounter.to-string;
        write "@.comment" + commentId + " = private constant [" ;
        write value.length-with-null ;
        write " x i8] c\"" + value + "\\00\"\n" ;
        commentCounter = commentCounter + 1 ;
    }

    commentCounter = 1 ;
    for each value in language.block-comments
    {
        for each part in value
        {
            commentId = commentCounter.to-string;
            write "@.blockComment" + commentId + " = private constant [" ;
            write part.length-with-null ;
            write " x i8] c\"" + part + "\\00\"\n" ;
            commentCounter = commentCounter + 1 ;
        }        
    }

    quoteCounter = 1 ;
    for each value in language.quotes
    {
        quoteId = quoteCounter.to-string;
        write "@.quote" + quoteId + " = private constant [" ;
        quoteName = "<" + value.name + ">" ;
        write quoteName.length-with-null ;
        write " x i8] c\"" + quoteName + "\\00\"\n" ;
        quoteCounter = quoteCounter + 1 ;

        for each part in value
        {
            quoteId = quoteCounter.to-string;
            write "@.quote" + quoteId + " = private constant [" ;
            cleanPart = part.unescaped ;
            write cleanPart.length-with-null ;
            write " x i8] c\"" ;
            write part.llvm-escaped ;
            write "\\00\"\n" ;
            quoteCounter = quoteCounter + 1 ;
        }        
    }

    ruleCounter = 1 ;
    for each value in language.keywords
    {
        strippedValue = value.quote-stripped ;
        ruleId = ruleCounter.to-string ;
        write "@.rule" + ruleId + " = private constant [" ;
        cleanPart = strippedValue.unescaped ;
        write cleanPart.length-with-null ;
        write " x i8] c\"" ;
        write strippedValue.llvm-escaped ;
        write "\\00\"\n" ;
        ruleCounter = ruleCounter + 1 ;
    }

    for each value in language.lexemes
    {
        if value.is-optional
        {
        }
        else
        {
            strippedValue = value.name.quote-stripped ;
            strippedValue = "<" + strippedValue + ">" ;
            ruleId = ruleCounter.to-string ;
            write "@.rule" + ruleId + " = private constant [" ;
            cleanPart = strippedValue.unescaped ;
            write cleanPart.length-with-null ;
            write " x i8] c\"" ;
            write strippedValue.llvm-escaped ;
            write "\\00\"\n" ;
            ruleCounter = ruleCounter + 1 ;

            strippedValue = value.quote-stripped ;
            ruleId = ruleCounter.to-string ;
            write "@.rule" + ruleId + " = private constant [" ;
            cleanPart = strippedValue.unescaped ;
            write cleanPart.length-with-null ;
            write " x i8] c\"" ;
            write strippedValue.llvm-escaped ;
            write "\\00\"\n" ;
            ruleCounter = ruleCounter + 1 ;
        }
    }

    for each value in language.operators
    {
        strippedValue = value.quote-stripped ;
        ruleId = ruleCounter.to-string ;
        write "@.rule" + ruleId + " = private constant [" ;
        cleanPart = strippedValue.unescaped ;
        write cleanPart.length-with-null ;
        write " x i8] c\"" ;
        write strippedValue.llvm-escaped ;
        write "\\00\"\n" ;
        ruleCounter = ruleCounter + 1 ;

        strippedValue = value.quote-stripped ;
        strippedValue = strippedValue.double-regex-escaped ;
        ruleId = ruleCounter.to-string ;
        write "@.rule" + ruleId + " = private constant [" ;
        cleanPart = strippedValue.unescaped ;
        write cleanPart.length-with-null ;
        write " x i8] c\"" ;
        write strippedValue.llvm-escaped ;
        write "\\00\"\n" ;
        ruleCounter = ruleCounter + 1 ;
    }

    for each value in language.terminators
    {
        strippedValue = value.quote-stripped ;
        ruleId = ruleCounter.to-string ;
        write "@.rule" + ruleId + " = private constant [" ;
        cleanPart = strippedValue.unescaped ;
        write cleanPart.length-with-null ;
        write " x i8] c\"" ;
        write strippedValue.llvm-escaped ;
        write "\\00\"\n" ;
        ruleCounter = ruleCounter + 1 ;

        strippedValue = value.quote-stripped ;
        strippedValue = strippedValue.double-regex-escaped ;
        ruleId = ruleCounter.to-string ;
        write "@.rule" + ruleId + " = private constant [" ;
        cleanPart = strippedValue.unescaped ;
        write cleanPart.length-with-null ;
        write " x i8] c\"" ;
        write strippedValue.llvm-escaped ;
        write "\\00\"\n" ;
        ruleCounter = ruleCounter + 1 ;
    }

    // parser constants
    productionCounter = 1 ;
    for each production in language.productions
    {
        productionName = production.name;
        productionId = productionCounter.to-string ;
        productionCounter = productionCounter + 1 ;
        write "@.production" + productionId + " = private constant [" ;
        cleanPart = productionName.unescaped ;
        write cleanPart.length-with-null ;
        write " x i8] c\"" ;
        write productionName.llvm-escaped ;
        write "\\00\"\n" ;

        for each production-name in production.names
        {
            productionId = productionCounter.to-string ;
            productionCounter = productionCounter + 1 ;
            write "@.production" + productionId + " = private constant [" ;
            cleanPart = production-name.unescaped ;
            write cleanPart.length-with-null ;
            write " x i8] c\"" ;
            write production-name.llvm-escaped ;
            write "\\00\"\n" ;
        }
    }

    write "@.languageName = private constant [" ;
    write language.name.length-with-null ;
    write " x i8] c\"" + language.name + "\\00\"\n" ;

    // pass names
    for each compiler-pass in language.passes
    {
        write "@.pass_" + compiler-pass.name + " = private constant [" ;
        write compiler-pass.name.length-with-null ;
        write " x i8] c\"" + compiler-pass.name + "\\00\"\n" ;
    }

    // functions for passes...

    write "\n" ;
    // the entry point
    write "define ccc i32 @main(i32 %argumentCount, i8** %argumentList) nounwind\n{\n" ;

    // title blurb
    write "\t%" + ssi-counter + " = call i32 @puts(i8* getelementptr inbounds ([" ;
    write title.length-with-null ;
    write " x i8]* @.message1, i32 0, i32 0))\n" ;
    write "\t%" + ssi-counter + " = call i32 @puts(i8* getelementptr inbounds ([67 x i8]* @.message2, i32 0, i32 0))\n" ;

    // parse command line
    write "\t%" + ssi-counter + " = call i32 @clParseCommandLine(i32 %argumentCount, i8** %argumentList)\n" ;

    // check for output file
    outputFile = ssi-counter ;
    write "\t%" + outputFile + " = call i32 @clHasSwitch(i8* getelementptr inbounds ([2 x i8]* @.outputSwitchShort, i32 0, i32 0))\n" ;
    outputFileCheck = ssi-counter ;
    write "\t%" + outputFileCheck + " = icmp ne i32 %" + outputFile + ", 0\n" ;
    write "\tbr i1 %" + outputFileCheck + ", label %hasOutputFile, label %noOutputFile\n" ;

    write "noOutputFile:\n";
    write "\t%" + ssi-counter + " = call i32 @puts(i8* getelementptr inbounds ([42 x i8]* @.error1002, i32 0, i32 0))\n" ;
    write "\tret i32 -1\n" ;

    write "hasOutputFile:\n" ;

    outputFileName = ssi-counter ;
    write "\t%" + outputFileName + " = call i8* @clMapSwitch(i8* getelementptr inbounds ([2 x i8]* @.outputSwitchShort, i32 0, i32 0))\n" ;

    // check for input files
    fileCount = ssi-counter ;
    write "\t%" + fileCount + " = call i32 @clFileCount()\n" ;
    fileCountCheck = ssi-counter;
    write "\t%" + fileCountCheck + " = icmp ne i32 %" + fileCount + ", 0\n" ;
    write "\tbr i1 %" + fileCountCheck + ", label %hasFiles, label %noFiles\n"  ;
    
    write "noFiles:\n";
    write "\t%" + ssi-counter + " = call i32 @puts(i8* getelementptr inbounds ([43 x i8]* @.error1001, i32 0, i32 0))\n" ;
    write "\tret i32 -1\n" ;

    write "hasFiles:\n" ;

    // set up lexer
    

    commentCounter = 1 ;
    for each value in language.line-comments
    {
        commentId = commentCounter.to-string;
        write "\t%" + ssi-counter + " = call i32 @clLexerLineComment(i8* getelementptr inbounds ([" ;
        write value.length-with-null ;
        write " x i8]* @.comment" + commentId + ", i32 0, i32 0))\n" ;
        commentCounter = commentCounter + 1 ;
    }

    commentCounter = 1 ;
    for each value in language.block-comments
    {
        write "\t%" + ssi-counter + " = call i32 @clLexerBlockComment(" ;
        joiner = ", " ;
        for each part in value
        {
            commentId = commentCounter.to-string;
            write "i8* getelementptr inbounds ([" ;
            write part.length-with-null ;
            write " x i8]* @.blockComment" + commentId + ", i32 0, i32 0)";
            write joiner ;
            commentCounter = commentCounter + 1 ;
            joiner = "" ;
        }
        write ")\n" ;
    }

    quoteCounter = 1 ;
    for each value in language.quotes
    {
        quoteId = quoteCounter.to-string;
        write "\t%" + ssi-counter + " = call i32 @clLexerQuote(" ;
        write "i8* getelementptr inbounds ([" ;
        quoteName = "<" + value.name + ">" ;
        write quoteName.length-with-null ;
        write " x i8]* @.quote" + quoteId + ", i32 0, i32 0), ";
        rest = "" ;
        quoteCounter = quoteCounter + 1 ;
        for each part in value
        {
            quoteId = quoteCounter.to-string;
            rest = rest + "i8* getelementptr inbounds ([" ;
            cleanPart = part.unescaped ;
            rest = rest + cleanPart.length-with-null ;
            rest = rest +  " x i8]* @.quote" + quoteId + ", i32 0, i32 0), ";
            quoteCounter = quoteCounter + 1 ;
        }

        rest = rest - ", " ;
        write rest + ")\n" ;
    }

    ruleCounter = 1 ;
    for each value in language.keywords
    {
        strippedValue = value.quote-stripped ;
        ruleId = ruleCounter.to-string ;
        write "\t%" + ssi-counter + " = call i32 @clLexerRule(" ;
        write "i8* getelementptr inbounds ([" ;
        cleanPart = strippedValue.unescaped ;
        write cleanPart.length-with-null ;
        write " x i8]* @.rule" + ruleId + ", i32 0, i32 0), ";
        write "i8* getelementptr inbounds ([" ;
        write cleanPart.length-with-null ;
        write " x i8]* @.rule" + ruleId + ", i32 0, i32 0))\n";
        ruleCounter = ruleCounter + 1 ;
    }

    for each value in language.lexemes
    {
        if value.is-optional
        {
        }
        else
        {
            strippedValue = value.name.quote-stripped ;
            strippedValue = "<" + strippedValue + ">" ;
            ruleId = ruleCounter.to-string ;
            write "\t%" + ssi-counter + " = call i32 @clLexerRule(" ;
            write "i8* getelementptr inbounds ([" ;
            cleanPart = strippedValue.unescaped ;
            write cleanPart.length-with-null ;
            write " x i8]* @.rule" + ruleId + ", i32 0, i32 0), ";
            ruleCounter = ruleCounter + 1 ;

            strippedValue = value.quote-stripped ;
            ruleId = ruleCounter.to-string ;
            write "i8* getelementptr inbounds ([" ;
            cleanPart = strippedValue.unescaped ;
            write cleanPart.length-with-null ;
            write " x i8]* @.rule" + ruleId + ", i32 0, i32 0))\n";
            ruleCounter = ruleCounter + 1 ;
        }
    }

    for each value in language.operators
    {
        strippedValue = value.quote-stripped ;
        ruleId = ruleCounter.to-string ;
        write "\t%" + ssi-counter + " = call i32 @clLexerRule(" ;
        write "i8* getelementptr inbounds ([" ;
        cleanPart = strippedValue.unescaped ;
        write cleanPart.length-with-null ;
        write " x i8]* @.rule" + ruleId + ", i32 0, i32 0), ";
        ruleCounter = ruleCounter + 1 ;

        strippedValue = value.quote-stripped ;
        strippedValue = strippedValue.double-regex-escaped ;
        ruleId = ruleCounter.to-string ;
        write "i8* getelementptr inbounds ([" ;
        cleanPart = strippedValue.unescaped ;
        write cleanPart.length-with-null ;
        write " x i8]* @.rule" + ruleId + ", i32 0, i32 0))\n";
        ruleCounter = ruleCounter + 1 ;
    }

    for each value in language.terminators
    {
        strippedValue = value.quote-stripped ;
        ruleId = ruleCounter.to-string ;
        write "\t%" + ssi-counter + " = call i32 @clLexerRule(" ;
        write "i8* getelementptr inbounds ([" ;
        cleanPart = strippedValue.unescaped ;
        write cleanPart.length-with-null ;
        write " x i8]* @.rule" + ruleId + ", i32 0, i32 0), ";
        ruleCounter = ruleCounter + 1 ;

        strippedValue = value.quote-stripped ;
        strippedValue = strippedValue.double-regex-escaped ;
        ruleId = ruleCounter.to-string ;
        write "i8* getelementptr inbounds ([" ;
        cleanPart = strippedValue.unescaped ;
        write cleanPart.length-with-null ;
        write " x i8]* @.rule" + ruleId + ", i32 0, i32 0))\n";
        ruleCounter = ruleCounter + 1 ;
    }

    // get it to lex all the files
    write "\t%" + ssi-counter + " = call i32 @puts(i8* getelementptr inbounds ([16 x i8]* @.message3, i32 0, i32 0))\n" ;

    // do a phi (!)
    // this is necessary for the loop variable to increment but start at zero
    // whilst respecting SSA
    lexCounter = ssi-counter ;
    nextCounter = ssi-counter ;
    write "\tbr label %lexHeader\n" ;
    write "lexHeader:\n" ;
    write "\tbr label %lexNextFile\n" ;
    write "lexNextFile:\n" ;
    write "\t%" + lexCounter + " = phi i32 [0, %lexHeader], [%" + nextCounter + ", %lexNextFile]\n" ;
    write "\t%" + nextCounter + " = add i32 %" + lexCounter + ", 1\n" ;

    lexFilename = ssi-counter;
    write "\t%" + lexFilename + " = call i8* @clGetFile(i32 %" + lexCounter + ")\n" ;
    //write "\t%" + ssi-counter + " = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([7 x i8]* @.message4, i32 0, i32 0), i8* %" + lexFilename + ")\n" ;
    write "\t%" + ssi-counter + " = call i32 @puts(i8* %" + lexFilename + ")\n" ;
    write "\t%" + ssi-counter + " = call i32 @clLex(i8* %" + lexFilename + ")\n" ;

    loopCheck = ssi-counter;
    write "\t%" + loopCheck + " = icmp slt i32 %" + nextCounter + ", %" + fileCount + "\n" ;
    write "\tbr i1 %" + loopCheck + ", label %lexNextFile, label %lexDone\n" ;
    
    write "lexDone:\n" ;

    // setup parser
    productionCounter = 1 ;
    for each production in language.productions
    {
        productionName = production.name;
        productionId = productionCounter.to-string ;
        productionCounter = productionCounter + 1 ;
        productionNameParameter = "i8* getelementptr inbounds ([" ;
        cleanPart = productionName.unescaped ;
        productionNameParameter = productionNameParameter + cleanPart.length-with-null ;
        productionNameParameter = productionNameParameter +  " x i8]* @.production" + productionId ;
        productionNameParameter = productionNameParameter + ", i32 0, i32 0)" ;

        for each production-name in production.names
        {
            productionId = productionCounter.to-string ;
            productionCounter = productionCounter + 1 ;
            nameParameter = "i8* getelementptr inbounds ([" ;
            cleanPart = production-name.unescaped ;
            nameParameter = nameParameter + cleanPart.length-with-null ;
            nameParameter = nameParameter +  " x i8]* @.production" + productionId ;
            nameParameter = nameParameter + ", i32 0, i32 0)" ;

            listValue = "0" ;
            nonEmptyValue = "0" ;
            optionalValue = "0" ;

            if production-name.is-list
            {
                listValue = "1";
            }

            if production-name.is-optional
            {
                optionalValue = "1";
            }

            if production-name.is-non-empty
            {
                nonEmptyValue = "1";
            }

            write "\t%" + ssi-counter + " = call i32 @clParseAppendExpression(" + nameParameter
                + ", i8 " + listValue + ", i8 " + nonEmptyValue + ", i8 " + optionalValue + ")\n" ;
        }

        write "\t%" + ssi-counter + " = call i32 @clParseCreateProduction(" + productionNameParameter + ")\n" ;
    }

    grammarNameParameter = "i8* getelementptr inbounds ([" ;
    grammarNameParameter = grammarNameParameter + language.name.length-with-null ;
    grammarNameParameter = grammarNameParameter + " x i8]* @.languageName, i32 0, i32 0)" ;
    write "\t%" + ssi-counter + " = call i32 @clParseCreateGrammar(" + grammarNameParameter + ")\n" ;

    // get it to parse all the lexer results
    write "\t%" + ssi-counter + " = call i32 @puts(i8* getelementptr inbounds ([17 x i8]* @.message4, i32 0, i32 0))\n" ;

    // do a phi (!)
    // this is necessary for the loop variable to increment but start at zero
    // whilst respecting SSA
    parseCounter = ssi-counter ;
    nextCounter = ssi-counter ;
    write "\tbr label %parseHeader\n" ;
    write "parseHeader:\n" ;
    write "\tbr label %parseNextFile\n" ;
    write "parseNextFile:\n" ;
    write "\t%" + parseCounter + " = phi i32 [0, %parseHeader], [%" + nextCounter + ", %parseNextFile]\n" ;
    write "\t%" + nextCounter + " = add i32 %" + parseCounter + ", 1\n" ;

    parseFilename = ssi-counter;
    write "\t%" + parseFilename + " = call i8* @clGetFile(i32 %" + parseCounter + ")\n" ;
    write "\t%" + ssi-counter + " = call i32 @puts(i8* %" + parseFilename + ")\n" ;
    write "\t%" + ssi-counter + " = call i32 @clParseLex(i32 %" + parseCounter + ")\n" ;

    loopCheck = ssi-counter;
    write "\t%" + loopCheck + " = icmp slt i32 %" + nextCounter + ", %" + fileCount + "\n" ;
    write "\tbr i1 %" + loopCheck + ", label %parseNextFile, label %parseDone\n" ;
    
    write "parseDone:\n" ;

    // check for each pass having it's switch set.
    for each compiler-pass in language.passes
    {
        hasSwitchId = ssi-counter ;
        switchCheckId = ssi-counter ;
        write "\t%" + hasSwitchId + " = call i32 @clHasSwitch(i8* getelementptr inbounds ([" ;
        write compiler-pass.name.length-with-null ;
        write " x i8]* @.pass_" + compiler-pass.name + ", i32 0, i32 0))\n" ;
        write "\t%" + switchCheckId + " = icmp ne i32 %" + hasSwitchId + ", 0\n" ;
        write "\tbr i1 %" + switchCheckId
            + ", label %doPass" + compiler-pass.name
            + ", label %skipPass" +  compiler-pass.name + "\n" ;
        
        write "doPass" +  compiler-pass.name + ":\n" ;
        // do the pass



        write "skipPass" +  compiler-pass.name + ":\n" ;
    }

    write "\tret i32 0\n" ;
    write "}\n" ;

}
