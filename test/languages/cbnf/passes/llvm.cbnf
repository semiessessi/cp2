// Copyright (c) 2021 Cranium Software

pass "llvm" switch
{
    output language.name + ".llvm" ;

    write "; LLVM IR code for compiler for " + language.name + "\n\n" ;

    // externs...
    write "declare ccc i32 @puts( i8* nocapture ) nounwind\n" ;
    write "declare ccc i32 @clParseCommandLine( i32, i8** nocapture ) nounwind\n" ;
    write "declare ccc i32 @clHasSwitch( i8* nocapture ) nounwind\n" ;
    write "declare ccc i8* @clMapSwitch( i8* nocapture ) nounwind\n" ;
    write "declare ccc i32 @clFileCount() nounwind\n" ;

    write "\n" ;

    // constants...
    write "@.message1 = private constant [24 x i8] c\"CBNF - CP2 Grammar Tool\\00\"\n" ;
    write "@.message2 = private constant [67 x i8] c\"Copyright (c) 2017-2021 Cranium Software Ltd. All rights reserved.\\00\"\n" ;
    write "@.error1001 = private constant [43 x i8] c\"cbnf: error 1001: No source files provided\\00\"\n" ;
    write "@.error1002 = private constant [42 x i8] c\"cbnf: error 1002: No output path provided\\00\"\n" ;
    write "@.outputSwitchShort = private constant [2 x i8] c\"o\\00\"\n" ;

    // lexer constants
    for each value in language.line-comments
    {
        //write "@.comment \"" + value + "\" ;\n" ;
    }

    // check for each pass having it's switch set.
    for each compiler-pass in language.passes
    {
        // todo: length and content
        write "@.pass_" + compiler-pass.name + " = private constant [5 x i8] c\"test\\00\"\n" ;
    }

    // functions for passes...

    // the entry point
    // SE - TODO: allow return code + more?
    // what about 'not windows'?
    write "define ccc i32 @main(i32 %argumentCount, i8** %argumentList) nounwind\n{\n" ;
    write "\t%" + ssi-counter + " = call i32 @puts(i8* getelementptr inbounds ([24 x i8]* @.message1, i32 0, i32 0))\n" ;
    write "\t%" + ssi-counter + " = call i32 @puts(i8* getelementptr inbounds ([67 x i8]* @.message2, i32 0, i32 0))\n" ;
    write "\t%" + ssi-counter + " = call i32 @clParseCommandLine(i32 %argumentCount, i8** %argumentList)\n" ;

    outputFile = ssi-counter ;
    write "\t%" + outputFile + " = call i32 @clHasSwitch(i8* getelementptr inbounds ([2 x i8]* @.outputSwitchShort, i32 0, i32 0))\n" ;
    outputFileCheck = ssi-counter ;
    write "\t%" + outputFileCheck + " = icmp ne i32 %" + outputFile + ", 0\n" ;
    write "\tbr i1 %" + outputFileCheck + ", label %hasOutputFile, label %noOutputFile\n" ;

    write "noOutputFile:\n";
    write "\t%" + ssi-counter + " = call i32 @puts(i8* getelementptr inbounds ([42 x i8]* @.error1002, i32 0, i32 0))\n" ;
    write "\tret i32 -1\n" ;

    write "hasOutputFile:\n" ;

    outputFileName = ssi-counter ;
    write "\t%" + outputFileName + " = call i8* @clMapSwitch(i8* getelementptr inbounds ([2 x i8]* @.outputSwitchShort, i32 0, i32 0))\n" ;

    fileCount = ssi-counter ;
    write "\t%" + fileCount + " = call i32 @clFileCount()\n" ;
    fileCountCheck = ssi-counter;
    write "\t%" + fileCountCheck + " = icmp ne i32 %" + fileCount + ", 0\n" ;
    write "\tbr i1 %" + fileCountCheck + ", label %hasFiles, label %noFiles\n"  ;
    
    write "noFiles:\n";
    write "\t%" + ssi-counter + " = call i32 @puts(i8* getelementptr inbounds ([43 x i8]* @.error1001, i32 0, i32 0))\n" ;
    write "\tret i32 -1\n" ;

    write "hasFiles:\n" ;

    // set up lexer

    // check for each pass having it's switch set.
    for each compiler-pass in language.passes
    {
        write "\t%" + ssi-counter + " = call i32 @clHasSwitch(i8* getelementptr inbounds ([5 x i8]* @.pass_" + compiler-pass.name + ", i32 0, i32 0))\n" ;
    }

    write "\tret i32 0\n" ;
    write "}\n";

}
